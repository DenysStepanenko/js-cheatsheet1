<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/3.0.1/modern-normalize.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@700&family=Roboto:wght@400;500;700&display=swap"
        rel="stylesheet" />
    <link rel="stylesheet" href="css/style.css" />
    <title>Шпаргалка по JavaScript</title>

<body>

    <header>
        <h1>Шпаргалка по JavaScript</h1>
    </header>

    <nav>
        <ul>
            <li>
                <a href="#">Модуль 1. Переменные и типы. Основы функций</a>
                <ul class="submenu">
                    <li><a href="#data-types">Типы данных</a></li>
                    <li><a href="#string">Строки</a></li>
                    <li><a href="#operator-||">Операторы сравнения</a></li>
                    <li><a href="#function_base">Основы функций</a></li>
                </ul>
            </li>
            <li>
                <a href="#">Модуль 2. Разветвления и циклы</a>
                <ul class="submenu">
                    <li><a href="#ramifications">Разветвления</a></li>
                    <li><a href="#logics">Логические операторы</a></li>
                    <li><a href="#methods">Методы строк</a></li>
                    <li><a href="#loops">Циклы</a></li>
                </ul>
            </li>
            <li>
                <a href="#">Модуль 3. Массивы и функции</a>
                <ul class="submenu">
                    <li><a href="#">Массивы</a></li>
                    <li><a href="#">Методы массива</a></li>
                    <li><a href="#">Итерация по массиву</a></li>
                    <li><a href="#">Функции (часть 2)</a></li>
                </ul>
            </li>
        </ul>
    </nav>


    <main>
        <section id="data-types">
            <h2>Типы данных</h2>
            <ul>
                <li><b>boolean</b> — Логический тип данных (Boolean) имеет только два значения: trueи false.
                    в отличие от строк, логический тип данных пишется без кавычек. Сравни:
                    true- это логическое значение;
                    " true" - это строка, содержащая слово true.
                    Он используется для выполнения логических операций и проверки условий. Например, на вопрос "включен
                    ли свет в комнате?"
                    можно ответить "да" (true) или "нет" (false).</li>
                <li><b>string</b> — Строка (String)(текст) является последовательностью символов, вложенных в одинарные
                    ''или двойные кавычки "".</li>
                <li><b>number</b> — Числа могут быть положительными или отрицательными, целыми
                    или дробными. Целая и дробная части числа разделяются точкой.</li>
                <li><b>null</b> — намеренное отсутствие данных явно указывает на отсутствие значения и часто
                    используется разработчиками для обозначения пустого значения. Это значение
                    должно быть явно присвоено переменной, чтобы указать, что переменная не содержит никаких
                    действительных данных.</li>
                <li><b>undefined</b> — переменная не имеет значения. Значение undefinedуказывает на неопределенность
                    значения переменной, то есть говорит нам, что значение сейчас неизвестно
                    или неопределенно</li>
                <li><b>symbol</b> — уникальный идентификатор</li>
                <li><b>bigint</b> — очень большие целые числа</li>
            </ul>
        </section>
        <section id="combo_operators">
            <h2>Комбинированные операторы</h2>
            Для всех арифметических операторов есть эквивалентные комбинированные операторы. Они позволяют более
            компактно выполнять
            арифметические операции и одновременно обновлять значение переменной исходя из ее предыдущего значения.
            Вот список арифметических операторов и их комбинированных эквивалентов:
            <ul>
                <li>Добавление : +=. Пример: x += yэквивалентноx = x + y</li>
                <li>Вычитание : -=. Пример: x -= yэквивалентноx = x - y</li>
                <li>Умножение : *=. Пример: x *= yэквивалентноx = x * y</li>
                <li>Деление : /=. Пример: x /= yэквивалентноx = x / y</li>
                <li>Остаток от деления : %=. Пример: x %= yэквивалентноx = x % y</li>
            </ul>
        </section>
        <section id="operator-||">
            <h2>Операторы сравнения в JavaScript</h2>
            <p>
                Сравнение всегда возвращает <code>true</code> или <code>false</code>. Основные операторы:
            <ul>
                <li><code>&gt;</code> и <code>&lt;</code> – больше и меньше</li>
                <li><code>&gt;=</code> и <code>&lt;=</code> – больше/меньше или равно</li>
            </ul>
            </p>

            <h3>Равенство</h3>
            <p>
                <strong>Несуровое:</strong> <code>==</code> и <code>!=</code> могут приводить типы (строка к числу и
                т.д.),
                поэтому
                результат бывает неожиданным (например, <code>5 == "5"</code> вернёт <code>true</code>).
                <br>
                <strong>Суровое:</strong> <code>===</code> и <code>!==</code> сравнивают и тип, и значение.
                Примеры: <code>5 === "5"</code> даёт <code>false</code>, так как типы разные.
            </p>

            <h3>Преобразование типов в число</h3>
            <ul>
                <li><code>Number(значение)</code> – явное преобразование.</li>
                <li>Булевый <code>true</code> превращается в <code>1</code>, <code>false</code> или <code>null</code> –
                    в
                    <code>0</code>, а
                    <code>undefined</code> и непреобразуемые строки дают <code>NaN</code>.
                </li>
                <li>Арифметические операции (<code>*</code>, <code>-</code>, <code>/</code>) часто делают неявное
                    преобразование к числу.</li>
            </ul>

            <h3>Парсинг чисел</h3>
            <ul>
                <li><code>Number.parseInt("5.5")</code> – возвращает целую часть (<code>5</code>).</li>
                <li><code>Number.parseFloat("5.5")</code> – возвращает число с плавающей точкой (<code>5.5</code>).</li>
            </ul>

            <h3>Math</h3>
            <ul>
                <li><code>Math.floor(1.7)</code> → <code>1</code> (округление вниз)</li>
                <li><code>Math.ceil(1.3)</code> → <code>2</code> (округление вверх)</li>
                <li><code>Math.round(1.5)</code> → <code>2</code> (округление по правилам математики)</li>
                <li><code>Math.max(10, 20)</code> → <code>20</code>; <code>Math.min(10, 20)</code> → <code>10</code>
                </li>
                <li><code>Math.random()</code> – случайное число от <code>0</code> до <code>1</code> (не включая
                    <code>1</code>)
                </li>
            </ul>

            <h3>Дробные числа</h3>
            <p>
                Иногда <code>0.1 + 0.2</code> не даёт ровно <code>0.3</code> из-за двоичного представления чисел.
                <br>Способы решения:
            <ul>
                <li>Умножать и делить на 10 (или 100) для точных вычислений.</li>
                <li>Использовать <code>toFixed()</code> для округления результата:
                    <br><code>(0.1 + 0.2).toFixed(1)</code> возвращает строку <code>"0.3"</code>.
                </li>
            </ul>
            </p>
        </section>
        <section id="Operator-typeof">
            <h2>Оператор typeof</h2>
            <ul>
                <li>Оператор typeofиспользуется для определения типа данных значения или выражения.
                    typeof operand
                    Вместо operandтебя указываешь переменную, литерал или выражение, тип которого ты хочешь определить.
                    Результатом
                    оператора typeofбудет строка, указывающая тип данных.
                    <pre><code>
    const quantity = 17 ;
    console . log ( typeof quantity); // выведет "number"
    
    const message = "JavaScript is awesome!" ;
    console . log ( typeof message); // выведет "string"
    
    const isSidebarOpen = false ;
    console . log ( typeof isSidebarOpen); // выведет "boolean"
    
    let username;
    console . log ( typeof username); // выведет "undefined"
    
    let status = null ;
    console . log ( typeof status); // выведет "object"

</code></pre>
                    Обрати внимание на проверку типа значения null. Важно понимать, что nullна самом деле это
                    примитивное значение, а не
                    объект.
                    Когда мы используем оператор typeofдля проверки типа значения null, он возвращает строку object. Это
                    может показаться
                    странным, поскольку nullэто фактически отсутствие значения, а не объект. Об этом часто спрашивают на
                    собеседованиях.
                    Причина этого в том, что в ранних версиях JavaScript nullбыл рассмотрен как специальный случай
                    объекта. Это была ошибка
                    в реализации языка, сохраненная для обеспечения обратной совместимости с существующим кодом. Поэтому
                    typeofприменительно
                    к null, он возвращает object, чтобы сохранить эту совместимость.
                </li>
            </ul>
        </section>

        <section id="string">
            <h2>Строки в JavaScript</h2>
            <p>
                Строка – это набор символов, где каждый символ имеет свой индекс (начиная с 0).
                Строки неизменяемы: нельзя изменить отдельный символ в уже созданной строке.
                Вместо этого создаётся новая строка.
            </p>

            <h3>Конкатенация</h3>
            <p>
                При сложении строки с любым другим типом данных результат всегда будет строкой.
                Пример: <code>"Hello" + 5</code> даёт <code>"Hello5"</code>.
            </p>

            <h3>Явное и неявное преобразование</h3>
            <ul>
                <li><strong>Явное</strong> – используем функцию <code>String()</code> для преобразования значения в
                    строку.</li>
                <li><strong>Неявное</strong> – происходит автоматически, например при сложении строки с другим типом
                    данных.
                </li>
            </ul>

            <h3>Шаблонные строки (Template literals)</h3>
            <p>
                Оборачиваются в обратные кавычки (``) и позволяют встраивать динамические значения:
            </p>
            <pre><code>
  const name = "Mango";
  const room = 207;
  const message = `Привет, ${name}! Номер: ${room}`;
  </code></pre>

            <h3>Свойство <code>length</code></h3>
            <p>
                <code>строка.length</code> возвращает количество символов в строке.
                Пример: <code>"Hello".length</code> даёт <code>5</code>.
            </p>

            <h3>Индексация</h3>
            <ul>
                <li>Первый символ имеет индекс <strong>0</strong>.</li>
                <li>Последний символ – индекс <strong>строка.length - 1</strong>.</li>
                <li>Доступ к символу: <code>строка[индекс]</code>.</li>
            </ul>

            <h3>Неизменяемость</h3>
            <p>
                Нельзя напрямую изменить символ в существующей строке.
                Нужно создавать новую строку, если требуется замена символа.
            </p>
        </section>
        <section id="methods">
            <h2>Методы строк</h2>
            <ul>
                <li><b>startsWith()</b> — проверяет, начинается ли строка с указанного текста</li>
                <li><b>endsWith()</b> — проверяет, заканчивается ли строка указанным текстом</li>
                <li><b>includes()</b> — проверяет, содержится ли подстрока в строке</li>
                <li><b>slice()</b> — вырезает часть строки</li>
                <li><b>toUpperCase() / toLowerCase()</b> — изменение регистра</li>
                <li><b>trim()</b> — убирает пробелы по краям</li>
            </ul>
        </section>
        <section id="loops">
            <h2>Циклы в JavaScript</h2>
            <p>
                Циклы позволяют многократно выполнять один и тот же блок кода, что удобно для обработки данных, подсчёта
                сумм и
                реализации повторяющихся действий. Здесь собраны основные конструкции для организации повторного
                выполнения
                кода.
            </p>

            <h3>Цикл <code>while</code></h3>
            <p>
                Конструкция <code>while</code> выполняет тело цикла до тех пор, пока условие истинно. Условие
                проверяется перед
                каждой итерацией, поэтому если оно сразу ложно – тело может не выполниться ни разу.
            </p>
            <pre><code>
        let i = 1;
        while (i <= 5) {
            console.log(i);
            i++;
        }
          </code></pre>

            <h3>Цикл <code>do...while</code></h3>
            <p>
                Цикл <code>do...while</code> гарантирует выполнение тела хотя бы один раз, так как проверка условия
                происходит
                после первой итерации. Если условие истинно, цикл повторяется.
            </p>
            <pre><code>
        let i = 0;
        do {
            console.log("Count: " + i);
            i++;
        } while (i < 5);
          </code></pre>

            <h3>Цикл <code>for</code></h3>
            <p>
                Цикл <code>for</code> удобен, когда известно количество повторений. Его структура выглядит так:
                <code>for (инициализация; условие; пост-выражение) { тело }</code>.
                Инициализация выполняется один раз перед началом цикла, затем перед каждой итерацией проверяется
                условие, а
                пост-выражение обновляет счётчик после каждого прохода.
            </p>
            <pre><code>
        for (let i = 0; i < 5; i++) {
            console.log(i);
        }
          </code></pre>

            <h3>Инкремент и декремент</h3>
            <p>
                Операторы <code>++</code> и <code>--</code> увеличивают или уменьшают значение переменной на единицу.
                Префиксная
                запись (<code>++x</code> или <code>--x</code>) сначала изменяет значение, а затем возвращает его, в то
                время как
                постфиксная (<code>x++</code> или <code>x--</code>) сначала возвращает текущее значение, а затем
                производит
                изменение.
            </p>

            <h3>Оператор <code>break</code></h3>
            <p>
                Оператор <code>break</code> прерывает выполнение цикла и передаёт управление на первую инструкцию после
                цикла.
                Это полезно, когда необходимо остановить цикл при достижении определённого условия.
            </p>

            <h3>Оператор <code>return</code></h3>
            <p>
                Оператор <code>return</code> завершает выполнение функции и возвращает указанное значение. Если он
                применяется
                внутри цикла, то завершает не только цикл, но и всю функцию.
            </p>
        </section>
        <section id="logics">
            <h2>Логические операторы в JavaScript</h2>
            <p>
                <strong>Логическое преобразование (Boolean):</strong> значения <code>0</code>, <code>""</code>,
                <code>NaN</code>, <code>null</code>, <code>undefined</code> и <code>false</code> приводятся к
                <code>false</code>, остальные — к <code>true</code>.
            </p>
            <p>
                <strong>Логическое И (&&):</strong> проверяет операнды слева направо. Возвращает первое «ложное»
                значение или
                последнее «истинное». Если хотя бы один операнд <code>false</code>, результат будет «ложный» операнд;
                иначе —
                «истинный».
            </p>
            <p>
                <strong>Логическое ИЛИ (||):</strong> проверяет операнды слева направо. Возвращает первое «истинное»
                значение
                или последнее «ложное», если все операнды «ложные».
            </p>
            <p>
                <strong>Логическое НЕ (!):</strong> приводит операнд к булевому типу и инвертирует его
                (<code>true</code> ↔
                <code>false</code>).
            </p>
        </section>
        <section id="logic">
            <h2>Логические операторы</h2>
            <ul>
                <li><b>!</b> — НЕ (инверсия), пример: <code>!true → false</code></li>
                <li><b>||</b> — ИЛИ, вернёт <code>true</code>, если хотя бы одно true</li>
                <li><b>&&</b> — И, вернёт <code>true</code>, если все условия верны</li>
            </ul>
        </section>
        <section id="function_base">
            <h2>Основы функций в JavaScript</h2>
            <p>
                Функция — это блок кода, который выполняет задачу и может возвращать результат.
                Чтобы вызвать функцию, нужно написать её имя и круглые скобки. Пример:
                <code>myFunction()</code>.
            </p>

            <h3>Параметры и аргументы</h3>
            <p>
                При объявлении функции в скобках указывают параметры (локальные переменные).
                При вызове функции в скобках передают аргументы (значения для параметров).
            </p>

            <h3>Возврат значения</h3>
            <p>
                <code>return</code> возвращает результат из функции. После
                <code>return</code> код функции не выполняется. Если <code>return</code> нет,
                функция возвращает <code>undefined</code>.
            </p>

            <h3>Порядок выполнения</h3>
            <p>
                Код выполняется сверху вниз. При вызове функции управление передаётся
                в её тело, а после завершения — возвращается обратно.
            </p>

            <h3>Область видимости</h3>
            <p>
                <strong>Глобальные</strong> переменные объявляются вне функций и доступны
                везде. <strong>Локальные</strong> переменные объявляются внутри функции
                или блока кода и видны только там. Попытка обратиться к локальной переменной
                за пределами функции вызывает ошибку.
            </p>
        </section>

        <section id="functions">
            <h2>Функции</h2>
            <h3>Сумма чисел от 1 до N</h3>
            <pre><code>
function calculateTotal(number) {
    let total = 0, i = 1;
    while (i <= number) {
        total += i;
        i++;
    }
    return total;
}
            </code></pre>

            <h3>Сумма чётных чисел</h3>
            <pre><code>
function calculateEvenTotal(number) {
    let sum = 0;
    for (let i = 1; i <= number; i++) {
        if (i % 2 === 0) {
            sum += i;
        }
    }
    return sum;
}
            </code></pre>
        </section>
        <section id="ramifications">
            <h2>Условные конструкции (Разветвления)</h2>
            <p>
                Условные конструкции позволяют выполнять разный код в зависимости от того, истинно условие или нет.
            </p>

            <h3>if</h3>
            <p>
                Если условие истинно, выполняется указанный блок кода.
                <br>
                Пример: <code>if (условие) { // код }</code>
            </p>

            <h3>if...else</h3>
            <p>
                Если условие истинно – выполняется первый блок, если ложно – второй.
                <br>
                Пример: <code>if (условие) { // код если true } else { // код если false }</code>
            </p>

            <h3>else if</h3>
            <p>
                Позволяет проверить несколько условий последовательно – выполняется первый удовлетворяющий условие блок.
            </p>

            <h3>Тернарный оператор</h3>
            <p>
                Краткая форма для выбора значения на основе условия.
                <br>
                Пример: <code>const result = условие ? значение_если_true : значение_если_false;</code>
            </p>

            <h3>switch</h3>
            <p>
                Выбирает действие в зависимости от значения выражения. Каждый <code>case</code> сравнивается по строгому
                равенству.
                <br>
                Пример:
                <br>
                <code>
              switch(выражение) {<br>
              &nbsp;&nbsp;case значение1:<br>
              &nbsp;&nbsp;&nbsp;&nbsp;// код<br>
              &nbsp;&nbsp;&nbsp;&nbsp;break;<br>
              &nbsp;&nbsp;default:<br>
              &nbsp;&nbsp;&nbsp;&nbsp;// код по умолчанию<br>
              }
            </code>
            </p>

            <h3>Блочная область видимости</h3>
            <p>
                Переменные, объявленные внутри блока <code>{ ... }</code>, доступны только в этом блоке. Глобальные
                переменные
                видны во всём коде.
            </p>
        </section>
    </main>

    <footer>
        <p>© 2025 Шпаргалка по JavaScript</p>
    </footer>

</body>

</html>