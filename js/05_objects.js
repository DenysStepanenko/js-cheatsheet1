/**
 * ОБЪЕКТЫ В JAVASCRIPT
 * ===================
 * 
 * Этот файл содержит подробную информацию об объектах в JavaScript:
 * способы создания объектов, работа со свойствами, методы объектов,
 * прототипное наследование и другие важные концепции.
 */

// ===== СОЗДАНИЕ ОБЪЕКТОВ =====

/**
 * В JavaScript существует несколько способов создания объектов:
 * 
 * 1. Литерал объекта (Object literal) - самый распространенный способ
 * 2. Конструктор Object
 * 3. Функция-конструктор
 * 4. Метод Object.create()
 * 5. Классы (ES6+)
 */

/**
 * Литерал объекта - самый простой и распространенный способ
 * Синтаксис: { ключ1: значение1, ключ2: значение2, ... }
 */
const person = {
  name: "Иван",
  age: 30,
  city: "Москва"
};

/**
 * Конструктор Object - альтернативный способ
 * Менее предпочтителен, чем литерал объекта
 */
const user = new Object();
user.name = "Мария";
user.age = 25;
user.city = "Санкт-Петербург";

/**
 * Функция-конструктор - создает объекты с заданной структурой
 * Имя функции-конструктора обычно начинается с заглавной буквы
 * 
 * Внутри функции-конструктора:
 * - this указывает на создаваемый объект
 * - Свойства добавляются через this.имяСвойства
 * - Не нужен явный return
 */
function Employee(name, position, salary) {
  this.name = name;
  this.position = position;
  this.salary = salary;
  this.isActive = true;
}

const employee1 = new Employee("Алексей", "Разработчик", 100000);
console.log(employee1); // Employee { name: "Алексей", position: "Разработчик", salary: 100000, isActive: true }

/**
 * Object.create() - создает объект с указанным прототипом
 * Позволяет явно задать прототип для нового объекта
 */
const personProto = {
  greet: function() {
    return `Привет, меня зовут ${this.name}`;
  }
};

const john = Object.create(personProto);
john.name = "Джон";
console.log(john.greet()); // "Привет, меня зовут Джон"

// ===== ДОСТУП К СВОЙСТВАМ ОБЪЕКТА =====

/**
 * Существует два способа доступа к свойствам объекта:
 * 1. Через точку (obj.property)
 * 2. Через квадратные скобки (obj["property"])
 * 
 * Квадратные скобки полезны, когда:
 * - Имя свойства содержит пробелы или специальные символы
 * - Имя свойства хранится в переменной
 * - Имя свойства определяется динамически
 */

// Через точку (точечная нотация)
console.log(person.name); // "Иван"
console.log(person.age);  // 30

// Через квадратные скобки (скобочная нотация)
console.log(person["name"]); // "Иван"
console.log(person["age"]);  // 30

/**
 * Динамический доступ к свойствам через переменную
 * Это возможно только с использованием квадратных скобок
 */
const propertyName = "city";
console.log(person[propertyName]); // "Москва"

/**
 * Проверка наличия свойства
 * 
 * Оператор in проверяет наличие свойства в объекте или его прототипе
 * Метод hasOwnProperty() проверяет только собственные свойства объекта
 */

// Проверка наличия свойства с помощью оператора in
console.log("name" in person); // true
console.log("job" in person);  // false

// Проверка собственных свойств с помощью hasOwnProperty
console.log(person.hasOwnProperty("name")); // true
console.log(john.hasOwnProperty("greet"));  // false (унаследовано)

// ===== ИЗМЕНЕНИЕ ОБЪЕКТОВ =====

/**
 * Объекты в JavaScript являются изменяемыми (mutable),
 * даже если они объявлены через const.
 * 
 * const предотвращает переназначение переменной,
 * но не изменение содержимого объекта.
 */

// Добавление свойств
person.job = "Программист";
person["salary"] = 100000;

// Изменение свойств
person.age = 31;
person["city"] = "Казань";

// Удаление свойств с помощью оператора delete
delete person.salary;
console.log(person.salary); // undefined

// ===== МЕТОДЫ ОБЪЕКТОВ =====

/**
 * Методы - это функции, хранящиеся как свойства объекта.
 * Внутри метода this указывает на объект, которому принадлежит метод.
 */

// Добавление методов
person.greet = function() {
  return `Привет, меня зовут ${this.name}`;
};

console.log(person.greet()); // "Привет, меня зовут Иван"

/**
 * Сокращенный синтаксис методов (ES6+)
 * Вместо key: function() {} можно использовать key() {}
 */
const calculator = {
  a: 0,
  b: 0,
  
  // Сокращенный синтаксис методов
  add() {
    return this.a + this.b;
  },
  
  multiply() {
    return this.a * this.b;
  }
};

calculator.a = 5;
calculator.b = 3;
console.log(calculator.add());      // 8
console.log(calculator.multiply()); // 15

// ===== ПЕРЕБОР СВОЙСТВ ОБЪЕКТА =====

/**
 * Существует несколько способов перебора свойств объекта:
 * 
 * 1. for...in - перебирает все перечисляемые свойства объекта и его прототипа
 * 2. Object.keys() - возвращает массив собственных перечисляемых ключей объекта
 * 3. Object.values() - возвращает массив собственных перечисляемых значений объекта
 * 4. Object.entries() - возвращает массив пар [ключ, значение]
 */

// for...in - перебирает все перечисляемые свойства
for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}

/**
 * Object.keys() - возвращает массив ключей
 * Преимущества перед for...in:
 * - Возвращает только собственные свойства (не из прототипа)
 * - Возвращает только перечисляемые свойства
 * - Возвращает массив, с которым можно использовать методы массивов
 */
const keys = Object.keys(person);
console.log(keys); // ["name", "age", "city", "job", "greet"]

// Перебор с помощью Object.keys() и forEach
Object.keys(person).forEach(key => {
  console.log(`${key}: ${person[key]}`);
});

/**
 * Object.values() - возвращает массив значений
 * Появился в ES2017 (ES8)
 */
const values = Object.values(person);
console.log(values); // ["Иван", 31, "Казань", "Программист", function]

/**
 * Object.entries() - возвращает массив пар [ключ, значение]
 * Появился в ES2017 (ES8)
 * Удобен для преобразования объекта в Map или для деструктуризации
 */
const entries = Object.entries(person);
console.log(entries); // [["name", "Иван"], ["age", 31], ...]

// Перебор с помощью Object.entries() и деструктуризации
Object.entries(person).forEach(([key, value]) => {
  console.log(`${key}: ${value}`);
});

// ===== КОПИРОВАНИЕ И ОБЪЕДИНЕНИЕ ОБЪЕКТОВ =====

/**
 * В JavaScript объекты копируются по ссылке, а не по значению.
 * Это означает, что при присваивании объекта новой переменной,
 * обе переменные будут указывать на один и тот же объект.
 */

// Копирование по ссылке
const original = { a: 1, b: 2 };
const copy = original; // Обе переменные указывают на один объект
copy.a = 10;
console.log(original.a); // 10 (изменение в copy отразилось в original)

/**
 * Для создания независимой копии объекта можно использовать:
 * 
 * 1. Object.assign() - поверхностное копирование (shallow copy)
 * 2. Оператор spread (...) - поверхностное копирование
 * 3. JSON.parse(JSON.stringify()) - глубокое копирование (с ограничениями)
 * 
 * ВАЖНО: поверхностное копирование копирует только свойства первого уровня.
 * Вложенные объекты все равно копируются по ссылке.
 */

// Поверхностное копирование с Object.assign()
const personCopy = Object.assign({}, person);
personCopy.name = "Петр";
console.log(person.name);     // "Иван" (оригинал не изменился)
console.log(personCopy.name); // "Петр"

// Поверхностное копирование с оператором spread (...)
const anotherCopy = { ...person };
anotherCopy.age = 40;
console.log(person.age);      // 31 (оригинал не изменился)
console.log(anotherCopy.age); // 40

/**
 * Объединение объектов
 * Свойства из последующих объектов перезаписывают свойства с теми же именами
 * из предыдущих объектов.
 */
const defaults = { theme: "light", language: "ru" };
const userSettings = { theme: "dark" };
const settings = { ...defaults, ...userSettings };
console.log(settings); // { theme: "dark", language: "ru" }

// ===== ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ =====

/**
 * Деструктуризация объектов - синтаксис, позволяющий извлекать
 * свойства объекта в отдельные переменные.
 * 
 * Появилась в ES6 (ES2015) и значительно упрощает работу с объектами.
 */

// Базовая деструктуризация
const { name, age } = person;
console.log(name); // "Иван"
console.log(age);  // 31

/**
 * Деструктуризация с переименованием
 * Синтаксис: { исходное: новое }
 */
const { name: userName, age: userAge } = person;
console.log(userName); // "Иван"
console.log(userAge);  // 31

/**
 * Деструктуризация с значениями по умолчанию
 * Значения по умолчанию используются, если свойство отсутствует или undefined
 */
const { job, salary = 0 } = person;
console.log(job);    // "Программист"
console.log(salary); // 0 (значение по умолчанию)

/**
 * Вложенная деструктуризация
 * Позволяет извлекать свойства из вложенных объектов
 */
const company = {
  name: "ABC Corp",
  address: {
    street: "Ленина 10",
    city: "Москва",
    country: "Россия"
  }
};

const { address: { city: companyCity, country } } = company;
console.log(companyCity); // "Москва"
console.log(country);     // "Россия"

// ===== МЕТОДЫ OBJECT =====

/**
 * Object - встроенный объект JavaScript, предоставляющий
 * статические методы для работы с объектами.
 */

/**
 * Object.keys() - возвращает массив собственных перечисляемых ключей объекта
 */
console.log(Object.keys(person)); // ["name", "age", "city", "job", "greet"]

/**
 * Object.values() - возвращает массив собственных перечисляемых значений объекта
 */
console.log(Object.values(person)); // ["Иван", 31, "Казань", "Программист", function]

/**
 * Object.entries() - возвращает массив пар [ключ, значение]
 */
console.log(Object.entries(person)); // [["name", "Иван"], ["age", 31], ...]

/**
 * Object.fromEntries() - создает объект из массива пар [ключ, значение]
 * Это обратная операция к Object.entries()
 * Появился в ES2019 (ES10)
 */
const personEntries = [["name", "Иван"], ["age", 31]];
const newPerson = Object.fromEntries(personEntries);
console.log(newPerson); // { name: "Иван", age: 31 }

/**
 * Object.freeze() - замораживает объект
 * - Предотвращает добавление новых свойств
 * - Предотвращает удаление существующих свойств
 * - Предотвращает изменение существующих свойств
 * - Предотвращает изменение прототипа
 * 
 * ВАЖНО: Object.freeze() выполняет поверхностную заморозку.
 * Вложенные объекты не замораживаются.
 */
const frozenObj = Object.freeze({ x: 1, y: 2 });
frozenObj.x = 10; // В строгом режиме вызовет ошибку, иначе операция будет проигнорирована
console.log(frozenObj.x); // 1 (не изменилось)

/**
 * Object.seal() - запечатывает объект
 * - Предотвращает добавление новых свойств
 * - Предотвращает удаление существующих свойств
 * - Разрешает изменение существующих свойств
 * - Предотвращает изменение прототипа
 */
const sealedObj = Object.seal({ x: 1, y: 2 });
sealedObj.x = 10;     // Сработает
sealedObj.z = 3;      // Не сработает (в строгом режиме вызовет ошибку)
delete sealedObj.y;   // Не сработает (в строгом режиме вызовет ошибку)
console.log(sealedObj); // { x: 10, y: 2 }

// ===== ГЕТТЕРЫ И СЕТТЕРЫ =====

/**
 * Геттеры и сеттеры - специальные методы, которые выглядят как свойства,
 * но при обращении к ним выполняется код.
 * 
 * Они позволяют:
 * - Контролировать доступ к свойствам объекта
 * - Выполнять дополнительные действия при чтении или записи
 * - Создавать вычисляемые свойства
 */

const product = {
  name: "Телефон",
  _price: 1000, // Соглашение: префикс _ указывает на "приватное" свойство
  
  // Геттер - вызывается при чтении свойства
  get price() {
    return `$${this._price}`;
  },
  
  // Сеттер - вызывается при записи свойства
  set price(value) {
    if (value < 0) {
      throw new Error("Цена не может быть отрицательной");
    }
    this._price = value;
  }
};

// Использование геттера (выглядит как чтение свойства)
console.log(product.price); // "$1000"

// Использование сеттера (выглядит как запись свойства)
product.price = 1200;
console.log(product.price); // "$1200"

// Валидация в сеттере
// product.price = -100; // Error: Цена не может быть отрицательной

// ===== ПРОТОТИПНОЕ НАСЛЕДОВАНИЕ =====

/**
 * Прототипное наследование - фундаментальный механизм JavaScript,
 * позволяющий объектам наследовать свойства и методы от других объектов.
 * 
 * Каждый объект имеет внутреннюю ссылку на другой объект, называемый прототипом.
 * Если свойство не найдено в самом объекте, JavaScript ищет его в прототипе,
 * затем в прототипе прототипа и так далее, образуя цепочку прототипов.
 */

// Создание объекта с прототипом
const animal = {
  eats: true,
  walk() {
    console.log("Животное гуляет");
  }
};

// Object.create создает новый объект с указанным прототипом
const rabbit = Object.create(animal);
rabbit.jumps = true;

// Доступ к унаследованным свойствам
console.log(rabbit.eats);  // true (унаследовано от animal)
console.log(rabbit.jumps); // true (собственное свойство)
rabbit.walk();            // "Животное гуляет" (унаследованный метод)

/**
 * Проверка и изменение прототипа
 */
// Проверка прототипа
console.log(Object.getPrototypeOf(rabbit) === animal); // true

// Изменение прототипа существующего объекта (не рекомендуется из-за проблем с производительностью)
const longEar = Object.create(rabbit);
longEar.earLength = 10;
console.log(longEar.jumps); // true (унаследовано от rabbit)
console.log(longEar.eats);  // true (унаследовано от animal через rabbit)

/**
 * Цепочка прототипов
 * __proto__ - устаревший способ доступа к прототипу, но полезен для понимания
 */
console.log(longEar.__proto__ === rabbit);         // true
console.log(longEar.__proto__.__proto__ === animal); // true

/**
 * ПРАКТИЧЕСКИЕ СОВЕТЫ:
 * 
 * 1. Используйте литерал объекта {} для создания объектов вместо new Object()
 * 2. Используйте сокращенный синтаксис методов вместо function expressions
 * 3. Используйте Object.keys(), Object.values() или Object.entries() вместо for...in
 * 4. Помните, что объекты копируются по ссылке; используйте Object.assign() или spread оператор для создания копий
 * 5. Используйте деструктуризацию для извлечения свойств объекта
 * 6. Используйте геттеры и сеттеры для контроля доступа к свойствам
 * 7. Предпочитайте Object.create() для создания объектов с заданным прототипом
 * 8. Избегайте изменения __proto__ существующих объектов из-за проблем с производительностью
 */
