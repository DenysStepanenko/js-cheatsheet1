/**
 * ЦИКЛЫ И УПРАВЛЕНИЕ ПОТОКОМ В JAVASCRIPT
 * ======================================
 * 
 * Этот файл содержит подробную информацию о циклах и управлении потоком в JavaScript:
 * различные типы циклов, условные конструкции и обработка ошибок.
 */

// ===== ЦИКЛЫ FOR =====

/**
 * Цикл for - самый распространенный тип цикла в JavaScript.
 * Синтаксис: for (инициализация; условие; шаг) { тело цикла }
 * 
 * - инициализация: выполняется один раз перед началом цикла
 * - условие: проверяется перед каждой итерацией, цикл продолжается, пока условие истинно
 * - шаг: выполняется после каждой итерации
 */

// Стандартный цикл for
for (let i = 0; i < 5; i++) {
  console.log(i); // Выведет числа от 0 до 4
}

/**
 * Цикл for может иметь несколько переменных и операций в каждой части
 */
// Цикл for с несколькими переменными
for (let i = 0, j = 10; i < 5; i++, j--) {
  console.log(`i = ${i}, j = ${j}`); // i увеличивается, j уменьшается
}

/**
 * Операторы continue и break позволяют управлять выполнением цикла:
 * - continue: пропускает текущую итерацию и переходит к следующей
 * - break: полностью прерывает выполнение цикла
 */

// Пропуск итераций с continue
for (let i = 0; i < 10; i++) {
  if (i % 2 === 0) continue; // Пропускаем четные числа
  console.log(i); // Выведет только нечетные числа: 1, 3, 5, 7, 9
}

// Досрочное завершение цикла с break
for (let i = 0; i < 10; i++) {
  if (i === 5) break; // Выходим из цикла при i = 5
  console.log(i); // Выведет числа от 0 до 4
}

// ===== ЦИКЛ FOR...OF =====

/**
 * Цикл for...of - современный способ перебора элементов итерируемых объектов.
 * Синтаксис: for (const элемент of итерируемый) { тело цикла }
 * 
 * Преимущества:
 * - Более читаемый и краткий синтаксис
 * - Работает с любыми итерируемыми объектами (массивы, строки, Map, Set и др.)
 * - Нет необходимости работать с индексами
 */

// Перебор элементов массива
const fruits = ["яблоко", "банан", "апельсин"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Вывод:
// яблоко
// банан
// апельсин

/**
 * for...of можно использовать для перебора символов строки
 */
// Перебор символов строки
const str = "Hello";
for (const char of str) {
  console.log(char);
}
// Вывод:
// H
// e
// l
// l
// o

/**
 * for...of работает с объектами Map и Set
 */
// Перебор значений Map
const map = new Map([
  ["key1", "value1"],
  ["key2", "value2"]
]);
for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}
// Вывод:
// key1: value1
// key2: value2

// Перебор значений Set
const set = new Set([1, 2, 3, 2, 1]); // Дубликаты автоматически удаляются
for (const value of set) {
  console.log(value);
}
// Вывод:
// 1
// 2
// 3

// ===== ЦИКЛ FOR...IN =====

/**
 * Цикл for...in - используется для перебора свойств объекта.
 * Синтаксис: for (const ключ in объект) { тело цикла }
 * 
 * ВАЖНО: for...in перебирает все перечисляемые свойства объекта,
 * включая унаследованные свойства из прототипа.
 * 
 * Не рекомендуется использовать for...in для массивов, так как:
 * - Порядок перебора не гарантирован
 * - Перебирает не только элементы, но и другие свойства массива
 */

// Перебор свойств объекта
const person = {
  name: "Иван",
  age: 30,
  city: "Москва"
};
for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}
// Вывод:
// name: Иван
// age: 30
// city: Москва

/**
 * Для перебора только собственных свойств объекта (не унаследованных)
 * используйте метод hasOwnProperty() или Object.hasOwnProperty.call()
 */
// Перебор только собственных свойств
for (const key in person) {
  if (Object.hasOwnProperty.call(person, key)) {
    console.log(`${key}: ${person[key]}`);
  }
}

// ===== ЦИКЛ WHILE =====

/**
 * Цикл while - выполняет блок кода, пока условие истинно.
 * Синтаксис: while (условие) { тело цикла }
 * 
 * Условие проверяется перед каждой итерацией.
 * Если условие изначально ложно, тело цикла не выполнится ни разу.
 */

// Выполняется, пока условие истинно
let i = 0;
while (i < 5) {
  console.log(i); // Выведет числа от 0 до 4
  i++;
}

/**
 * В цикле while также можно использовать continue и break
 */
// Пример с условием в середине цикла
let j = 0;
while (j < 10) {
  j++;
  if (j % 2 === 0) continue; // Пропускаем четные числа
  console.log(j); // Выведет только нечетные числа: 1, 3, 5, 7, 9
  if (j === 7) break; // Выходим из цикла при j = 7
}

// ===== ЦИКЛ DO...WHILE =====

/**
 * Цикл do...while - выполняет блок кода хотя бы один раз, затем проверяет условие.
 * Синтаксис: do { тело цикла } while (условие);
 * 
 * Отличие от while: тело цикла выполняется хотя бы один раз,
 * даже если условие изначально ложно.
 */

// Выполняется хотя бы один раз, затем проверяется условие
let k = 0;
do {
  console.log(k); // Выведет числа от 0 до 4
  k++;
} while (k < 5);

/**
 * Пример, когда условие изначально ложно:
 * - В цикле while тело не выполнится ни разу
 * - В цикле do...while тело выполнится один раз
 */
// Пример, когда условие изначально ложно
let m = 10;
do {
  console.log(m); // Выведет 10 (один раз), несмотря на то, что условие ложно
  m++;
} while (m < 10);

// ===== ВЛОЖЕННЫЕ ЦИКЛЫ =====

/**
 * Вложенные циклы - это циклы внутри других циклов.
 * Они полезны для работы с многомерными структурами данных,
 * такими как матрицы (двумерные массивы).
 */

// Пример вложенных циклов для работы с двумерным массивом
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

for (let i = 0; i < matrix.length; i++) {
  for (let j = 0; j < matrix[i].length; j++) {
    console.log(`matrix[${i}][${j}] = ${matrix[i][j]}`);
  }
}

/**
 * Метки (labels) позволяют обращаться к внешним циклам из вложенных.
 * Это полезно, когда нужно выйти из нескольких уровней циклов сразу.
 */
// Пример с метками для выхода из вложенных циклов
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      console.log("Выход из обоих циклов");
      break outerLoop; // Выходим из внешнего цикла
    }
    console.log(`i = ${i}, j = ${j}`);
  }
}

// ===== МЕТОДЫ ПЕРЕБОРА МАССИВОВ =====

/**
 * JavaScript предоставляет множество методов для перебора и обработки массивов.
 * Эти методы более декларативны и часто более читаемы, чем обычные циклы.
 */

const numbers = [1, 2, 3, 4, 5];

/**
 * forEach - выполняет функцию для каждого элемента массива
 * Не возвращает новый массив, используется для побочных эффектов
 */
numbers.forEach((number, index) => {
  console.log(`numbers[${index}] = ${number}`);
});

/**
 * map - создает новый массив с результатами вызова функции для каждого элемента
 * Возвращает новый массив той же длины
 */
const doubled = numbers.map(number => number * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

/**
 * filter - создает новый массив с элементами, прошедшими проверку
 * Возвращает новый массив, который может быть короче исходного
 */
const evenNumbers = numbers.filter(number => number % 2 === 0);
console.log(evenNumbers); // [2, 4]

/**
 * find - возвращает первый элемент, удовлетворяющий условию
 * Возвращает undefined, если ни один элемент не удовлетворяет условию
 */
const found = numbers.find(number => number > 3);
console.log(found); // 4

/**
 * some - проверяет, удовлетворяет ли хотя бы один элемент условию
 * Возвращает true или false
 */
const hasEven = numbers.some(number => number % 2 === 0);
console.log(hasEven); // true

/**
 * every - проверяет, удовлетворяют ли все элементы условию
 * Возвращает true или false
 */
const allPositive = numbers.every(number => number > 0);
console.log(allPositive); // true

/**
 * reduce - сводит массив к одному значению
 * Применяет функцию к аккумулятору и каждому элементу массива
 */
const sum = numbers.reduce((total, number) => total + number, 0);
console.log(sum); // 15

// ===== УПРАВЛЕНИЕ ПОТОКОМ С ПОМОЩЬЮ УСЛОВНЫХ ОПЕРАТОРОВ =====

/**
 * Условные операторы позволяют выполнять разный код в зависимости от условий.
 */

/**
 * if...else - базовая условная конструкция
 * Синтаксис:
 * if (условие) {
 *   // код, если условие истинно
 * } else {
 *   // код, если условие ложно
 * }
 */
// if...else
const age = 18;
if (age >= 18) {
  console.log("Совершеннолетний");
} else {
  console.log("Несовершеннолетний");
}

/**
 * if...else if...else - для проверки нескольких условий
 * Синтаксис:
 * if (условие1) {
 *   // код, если условие1 истинно
 * } else if (условие2) {
 *   // код, если условие1 ложно, но условие2 истинно
 * } else {
 *   // код, если все условия ложны
 * }
 */
// if...else if...else
const score = 85;
if (score >= 90) {
  console.log("Отлично");
} else if (score >= 70) {
  console.log("Хорошо");
} else if (score >= 50) {
  console.log("Удовлетворительно");
} else {
  console.log("Неудовлетворительно");
}

/**
 * Тернарный оператор - сокращенная форма if...else
 * Синтаксис: условие ? выражение1 : выражение2
 * 
 * Если условие истинно, возвращается выражение1, иначе - выражение2.
 * Используйте тернарный оператор только для простых условий,
 * чтобы код оставался читаемым.
 */
// Тернарный оператор
const status = age >= 18 ? "Взрослый" : "Ребенок";
console.log(status); // "Взрослый"

/**
 * Вложенные тернарные операторы возможны, но могут сделать код трудночитаемым.
 * Используйте их с осторожностью или замените на if...else if...else.
 */
// Вложенные тернарные операторы (лучше избегать для читаемости)
const grade = score >= 90 ? "A" : score >= 80 ? "B" : score >= 70 ? "C" : "D";
console.log(grade); // "B"

/**
 * switch - удобен, когда нужно сравнить переменную с несколькими значениями
 * Синтаксис:
 * switch (выражение) {
 *   case значение1:
 *     // код, если выражение === значение1
 *     break;
 *   case значение2:
 *     // код, если выражение === значение2
 *     break;
 *   default:
 *     // код, если ни одно из значений не совпало
 * }
 * 
 * ВАЖНО: не забывайте break, иначе выполнение продолжится на следующих case
 */
// switch
const day = 2;
switch (day) {
  case 1:
    console.log("Понедельник");
    break;
  case 2:
    console.log("Вторник");
    break;
  case 3:
    console.log("Среда");
    break;
  default:
    console.log("Другой день");
}

/**
 * Проваливание (fall-through) в switch - когда намеренно опускается break,
 * чтобы несколько case выполняли один и тот же код.
 */
// switch без break (проваливание)
const month = 2;
switch (month) {
  case 12:
  case 1:
  case 2:
    console.log("Зима");
    break;
  case 3:
  case 4:
  case 5:
    console.log("Весна");
    break;
  default:
    console.log("Другое время года");
}

// ===== ОБРАБОТКА ОШИБОК С TRY...CATCH =====

/**
 * try...catch позволяет обрабатывать ошибки, не прерывая выполнение программы.
 * Синтаксис:
 * try {
 *   // код, который может вызвать ошибку
 * } catch (error) {
 *   // код обработки ошибки
 * }
 */

// Базовый пример
try {
  // Код, который может вызвать ошибку
  console.log(undefinedVariable); // Переменная не определена
} catch (error) {
  // Обработка ошибки
  console.log("Произошла ошибка:", error.message);
}
console.log("Выполнение продолжается"); // Этот код выполнится

/**
 * try...catch...finally - блок finally выполняется всегда,
 * независимо от того, произошла ошибка или нет.
 * 
 * Используется для кода, который должен выполниться в любом случае,
 * например, для освобождения ресурсов.
 */
// try...catch...finally
try {
  // Код, который может вызвать ошибку
  throw new Error("Пример ошибки");
} catch (error) {
  // Обработка ошибки
  console.log("Ошибка:", error.message);
} finally {
  // Этот блок выполнится в любом случае
  console.log("Блок finally выполнен");
}

/**
 * Создание собственных ошибок с помощью throw
 * Можно выбрасывать любые объекты, но рекомендуется использовать
 * экземпляры Error или его подклассов.
 */
// Создание собственных ошибок
function divide(a, b) {
  if (b === 0) {
    throw new Error("Деление на ноль недопустимо");
  }
  return a / b;
}

try {
  console.log(divide(10, 2)); // 5
  console.log(divide(10, 0)); // Вызовет ошибку
} catch (error) {
  console.log("Ошибка при делении:", error.message);
}

/**
 * ПРАКТИЧЕСКИЕ СОВЕТЫ:
 * 
 * 1. Используйте for...of вместо for для перебора массивов и других итерируемых объектов
 * 2. Используйте for...in только для перебора свойств объектов, не для массивов
 * 3. Предпочитайте методы массивов (forEach, map, filter, reduce) вместо циклов, когда это возможно
 * 4. Не забывайте break в switch, если не планируете проваливание
 * 5. Используйте try...catch для обработки ошибок, особенно при работе с внешними API
 * 6. Создавайте информативные сообщения об ошибках при использовании throw
 * 7. Используйте finally для кода, который должен выполниться независимо от наличия ошибок
 */
