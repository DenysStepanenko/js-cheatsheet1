/**
 * ФУНКЦИИ В JAVASCRIPT
 * ===================
 * 
 * Этот файл содержит подробную информацию о функциях в JavaScript:
 * различные способы их объявления, параметры, замыкания, рекурсия,
 * функции высшего порядка и методы функций.
 */

// ===== ОБЪЯВЛЕНИЕ ФУНКЦИЙ =====

/**
 * В JavaScript существует несколько способов объявления функций:
 * 
 * 1. Function Declaration (Объявление функции)
 * 2. Function Expression (Функциональное выражение)
 * 3. Arrow Function (Стрелочная функция)
 * 
 * Каждый способ имеет свои особенности и применяется в разных ситуациях.
 */

/**
 * Function Declaration (Объявление функции)
 * - Поднимается (hoisting): можно вызвать до объявления
 * - Имеет собственный this
 * - Имеет объект arguments
 */
function sayHello(name) {
  return `Привет, ${name}!`;
}
console.log(sayHello("Иван")); // "Привет, Иван!"

/**
 * Function Expression (Функциональное выражение)
 * - Не поднимается: нельзя вызвать до объявления
 * - Имеет собственный this
 * - Имеет объект arguments
 * - Может быть анонимной или именованной
 */
const greet = function(name) {
  return `Здравствуйте, ${name}!`;
};
console.log(greet("Мария")); // "Здравствуйте, Мария!"

/**
 * Arrow Function (Стрелочная функция)
 * - Не поднимается: нельзя вызвать до объявления
 * - Не имеет собственного this (берет из окружения)
 * - Не имеет объекта arguments
 * - Всегда анонимная
 * - Более краткий синтаксис
 */
const welcome = (name) => {
  return `Добро пожаловать, ${name}!`;
};
console.log(welcome("Алексей")); // "Добро пожаловать, Алексей!"

/**
 * Сокращенная запись стрелочной функции
 * - Если тело функции состоит из одного выражения, можно опустить фигурные скобки и return
 * - Если функция принимает только один параметр, можно опустить круглые скобки
 */
const add = (a, b) => a + b;  // Сокращенная запись для функции с одним выражением
console.log(add(2, 3)); // 5

const square = x => x * x;    // Сокращенная запись для функции с одним параметром
console.log(square(4)); // 16

// ===== ПАРАМЕТРЫ ФУНКЦИЙ =====

/**
 * Параметры по умолчанию
 * - Позволяют задать значения, которые будут использованы, если аргумент не передан
 * - Делают некоторые аргументы необязательными
 * - Могут быть выражениями, а не только константами
 */
function createUser(name = "Гость", age = 18, city = "Москва") {
  return `Имя: ${name}, Возраст: ${age}, Город: ${city}`;
}

console.log(createUser("Иван", 25, "Санкт-Петербург")); // "Имя: Иван, Возраст: 25, Город: Санкт-Петербург"
console.log(createUser("Анна")); // "Имя: Анна, Возраст: 18, Город: Москва"
console.log(createUser()); // "Имя: Гость, Возраст: 18, Город: Москва"

/**
 * Объект arguments
 * - Псевдомассив, содержащий все аргументы, переданные в функцию
 * - Доступен только в обычных функциях (не в стрелочных)
 * - Не имеет методов массива (map, filter и т.д.)
 * - Можно преобразовать в настоящий массив с помощью Array.from()
 */
function showArgs() {
  console.log(arguments); // Псевдомассив аргументов
  console.log(arguments.length); // Количество аргументов
  console.log(arguments[0]); // Первый аргумент
}

showArgs(1, "hello", true); // { '0': 1, '1': 'hello', '2': true, length: 3 }

/**
 * Преобразование arguments в массив
 * - Необходимо для использования методов массива
 */
function sumArgs() {
  // Преобразуем arguments в настоящий массив
  const args = Array.from(arguments);
  // Используем метод reduce для суммирования
  return args.reduce((sum, current) => sum + current, 0);
}

console.log(sumArgs(1, 2, 3, 4)); // 10

/**
 * Rest-параметр (современный способ вместо arguments)
 * - Собирает все аргументы в настоящий массив
 * - Обозначается многоточием перед именем параметра (...имя)
 * - Должен быть последним в списке параметров
 */
function sumRest(...numbers) {
  return numbers.reduce((sum, current) => sum + current, 0);
}

console.log(sumRest(1, 2, 3, 4)); // 10
console.log(sumRest(5, 10, 15)); // 30

/**
 * Деструктуризация параметров
 * - Позволяет извлекать свойства из объектов прямо в параметрах
 * - Можно задавать значения по умолчанию
 * - Делает код более читаемым
 */
function displayPerson({ name, age, city = "Неизвестно" }) {
  console.log(`${name}, ${age} лет, город: ${city}`);
}

displayPerson({ name: "Иван", age: 30, city: "Москва" }); // "Иван, 30 лет, город: Москва"
displayPerson({ name: "Анна", age: 25 }); // "Анна, 25 лет, город: Неизвестно"

// ===== ОБЛАСТЬ ВИДИМОСТИ И ЗАМЫКАНИЯ =====

/**
 * Область видимости (Scope) определяет доступность переменных.
 * В JavaScript есть:
 * - Глобальная область видимости (переменные доступны везде)
 * - Локальная область видимости (переменные доступны только внутри функции или блока)
 */

// Глобальная и локальная область видимости
let globalVar = "Я глобальная переменная";

function showScope() {
  let localVar = "Я локальная переменная";
  console.log(globalVar); // Доступ к глобальной переменной
  console.log(localVar); // Доступ к локальной переменной
}

showScope();
console.log(globalVar); // Доступ к глобальной переменной
// console.log(localVar); // Ошибка: localVar is not defined

/**
 * Замыкания (Closures)
 * - Функция вместе с ее лексическим окружением
 * - Позволяет функции запоминать и получать доступ к переменным из внешней области видимости
 * - Даже если внешняя функция завершила выполнение, внутренняя функция сохраняет доступ к переменным
 */
function createCounter() {
  let count = 0; // Переменная, захваченная замыканием
  
  return function() {
    return ++count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

/**
 * Пример практического использования замыканий
 * - Создание функций с предустановленными параметрами
 */
function createGreeting(greeting) {
  return function(name) {
    return `${greeting}, ${name}!`;
  };
}

const sayHi = createGreeting("Привет");
const sayBye = createGreeting("До свидания");

console.log(sayHi("Иван")); // "Привет, Иван!"
console.log(sayBye("Мария")); // "До свидания, Мария!"

// ===== РЕКУРСИЯ =====

/**
 * Рекурсия - это когда функция вызывает сама себя.
 * Для правильной рекурсии необходимо:
 * 1. Базовый случай (условие выхода из рекурсии)
 * 2. Рекурсивный случай (вызов функции с измененными аргументами)
 */

/**
 * Факториал числа (n! = n * (n-1) * ... * 1)
 * - Базовый случай: n <= 1, возвращаем 1
 * - Рекурсивный случай: n * factorial(n - 1)
 */
function factorial(n) {
  if (n <= 1) {
    return 1; // Базовый случай
  }
  return n * factorial(n - 1); // Рекурсивный вызов
}

console.log(factorial(5)); // 120 (5 * 4 * 3 * 2 * 1)

/**
 * Числа Фибоначчи (0, 1, 1, 2, 3, 5, 8, 13, ...)
 * - Базовые случаи: fib(0) = 0, fib(1) = 1
 * - Рекурсивный случай: fib(n) = fib(n-1) + fib(n-2)
 * 
 * ВНИМАНИЕ: Это неэффективная реализация, так как вычисления дублируются.
 * Для больших n лучше использовать итеративный подход или мемоизацию.
 */
function fibonacci(n) {
  if (n <= 1) {
    return n; // Базовые случаи: fib(0) = 0, fib(1) = 1
  }
  return fibonacci(n - 1) + fibonacci(n - 2); // Рекурсивный вызов
}

console.log(fibonacci(7)); // 13

// ===== ФУНКЦИИ ВЫСШЕГО ПОРЯДКА =====

/**
 * Функции высшего порядка - это функции, которые:
 * - Принимают другие функции в качестве аргументов
 * - Возвращают функции в качестве результата
 * - Или и то, и другое
 * 
 * Они являются основой функционального программирования в JavaScript.
 */

/**
 * Функция, принимающая другую функцию как аргумент
 * - Позволяет абстрагировать операцию от ее реализации
 * - Делает код более гибким и переиспользуемым
 */
function applyOperation(a, b, operation) {
  return operation(a, b);
}

// Передаем функции как аргументы
console.log(applyOperation(5, 3, (a, b) => a + b)); // 8 (сложение)
console.log(applyOperation(5, 3, (a, b) => a - b)); // 2 (вычитание)
console.log(applyOperation(5, 3, (a, b) => a * b)); // 15 (умножение)

/**
 * Функция, возвращающая другую функцию
 * - Позволяет создавать специализированные функции
 * - Основа для каррирования (разбиение функции с несколькими аргументами на последовательность функций с одним аргументом)
 */
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10 (2 * 5)
console.log(triple(5)); // 15 (3 * 5)

// ===== МЕТОДЫ ФУНКЦИЙ =====

/**
 * Функции в JavaScript - это объекты, и у них есть свои методы:
 * - call: вызывает функцию с указанным this и аргументами
 * - apply: то же, что и call, но аргументы передаются массивом
 * - bind: создает новую функцию с привязанным this и начальными аргументами
 */

/**
 * call - вызывает функцию с указанным this и аргументами
 * Синтаксис: func.call(thisArg, arg1, arg2, ...)
 */
function introduce(greeting) {
  console.log(`${greeting}, меня зовут ${this.name}`);
}

const person1 = { name: "Иван" };
const person2 = { name: "Мария" };

introduce.call(person1, "Привет"); // "Привет, меня зовут Иван"
introduce.call(person2, "Здравствуйте"); // "Здравствуйте, меня зовут Мария"

/**
 * apply - то же, что и call, но аргументы передаются массивом
 * Синтаксис: func.apply(thisArg, [arg1, arg2, ...])
 */
introduce.apply(person1, ["Добрый день"]); // "Добрый день, меня зовут Иван"

/**
 * bind - создает новую функцию с привязанным this и начальными аргументами
 * Синтаксис: func.bind(thisArg, arg1, arg2, ...)
 * 
 * В отличие от call и apply, bind не вызывает функцию, а возвращает новую
 */
const introduceIvan = introduce.bind(person1);
const introduceMaria = introduce.bind(person2);

introduceIvan("Привет"); // "Привет, меня зовут Иван"
introduceMaria("Здравствуйте"); // "Здравствуйте, меня зовут Мария"

// bind с предустановленными аргументами
const sayHelloToIvan = introduce.bind(person1, "Привет");
sayHelloToIvan(); // "Привет, меня зовут Иван"

/**
 * ПРАКТИЧЕСКИЕ СОВЕТЫ:
 * 
 * 1. Используйте Function Declaration для основных функций программы
 * 2. Используйте стрелочные функции для коротких колбэков и когда нужно сохранить this
 * 3. Используйте параметры по умолчанию вместо проверок на undefined
 * 4. Предпочитайте rest-параметр (...args) вместо arguments
 * 5. Используйте деструктуризацию параметров для объектов с множеством свойств
 * 6. Будьте осторожны с рекурсией - она может привести к переполнению стека
 * 7. Используйте функции высшего порядка для создания более абстрактного и гибкого кода
 * 8. Помните, что bind создает новую функцию, а call и apply вызывают существующую
 */
